Arguments: 
{'AGQ_GPTQ': False,
 'EBSS_calib': False,
 'a_asym': False,
 'a_bits': 16,
 'a_clip_ratio': 1.0,
 'a_dynamic_method': 'pertensor',
 'a_groupsize': -1,
 'act_order': False,
 'bsz': 32,
 'cal_dataset': 'wikitext2',
 'calib_path': './EBSS.json',
 'capture_layer_io': False,
 'distribute': False,
 'do_smooth': False,
 'down_group_size': 60,
 'eval_dataset': 'wikitext2',
 'fp32_had': False,
 'fully_quant': False,
 'gate_up_group_size': 60,
 'hf_token': None,
 'human_res': './res_moe_qwen3moe_base_w2_selfebss_nsample_128',
 'int8_down_proj': False,
 'k_asym': False,
 'k_bits': 16,
 'k_clip_ratio': 1.0,
 'k_groupsize': -1,
 'k_pre_rope': False,
 'layer_idx': 10,
 'lm_eval': False,
 'lm_eval_batch_size': 128,
 'load_qmodel_path': '/dataset/common/quant_model/moequant_qwen3moe_w2_selfebss_nsample_128_groupsize128_rotate.pth',
 'model': '/dataset/common/pretrain_model/Qwen3-30B-A3B-Base',
 'nsamples': 128,
 'online_hadamard': False,
 'percdamp': 0.01,
 'pre_eval': False,
 'quant_test': True,
 'rotate': False,
 'rotate_mode': 'hadamard',
 'rotation_seed': -1,
 'save_name': '20260126_183904',
 'save_path': '/export/home2/zihan/MoEQuant/code/log',
 'save_qmodel_path': None,
 'seed': 0,
 'shared_expert_act_calib': False,
 'static_test': False,
 'tasks': ['piqa',
           'hellaswag',
           'arc_easy',
           'arc_challenge',
           'winogrande',
           'lambada'],
 'v_asym': False,
 'v_bits': 16,
 'v_clip_ratio': 1.0,
 'v_groupsize': -1,
 'w_asym': False,
 'w_bits': 2,
 'w_clip': False,
 'w_groupsize': -1,
 'w_rtn': False,
 'wandb': False,
 'wandb_id': None,
 'wandb_project': None}
------------------------------------------------------------
---> Loading model with device_map=auto for multi-GPU support...
We will use 90% of the memory on device 0 for storing the model, and 10% for the buffer to avoid OOM. You can set `max_memory` in to a higher value to use more memory (at your own risk).
---> Loading /dataset/common/pretrain_model/Qwen3-30B-A3B-Base Model (class: Qwen3MoeForCausalLM) with seq_len: 2048
---> Using model-level rotary_emb for quantization
QuantAttention: detected q_norm/k_norm; applying RMSNorm on q/k heads.
QuantDecoderLayer: cache_position provided (shape=(2048,), device=cuda:0); use_cache=True past_key_value=DynamicCache
QuantAttention: qwen3-style forward position_embeddings=True past_key_value=True
